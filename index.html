<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sloths & Shrimpers Race</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        canvas {
            display: block;
            background-color: #2c5246;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }
        .character-btn {
            background-size: cover;
            background-position: center;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 4px solid transparent;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, border-color 0.2s;
        }
        .character-btn:hover {
            transform: scale(1.1);
            border-color: #ffffff;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center p-4 min-h-screen">
    <!-- Modal for messages -->
    <div id="modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden flex items-center justify-center z-50">
        <div class="bg-gray-800 p-6 rounded-2xl shadow-xl max-w-sm w-full text-center border-2 border-gray-700">
            <p id="modal-message" class="text-xl font-semibold mb-4 text-white"></p>
            <div id="story-container" class="mt-4 text-sm italic text-gray-300"></div>
            <div class="flex flex-col items-center gap-2 mt-4">
                <button id="close-modal-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-xl transition-colors">
                    OK
                </button>
                <a id="share-x-btn" class="inline-block bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-xl transition-colors hidden">
                    Share on X
                </a>
            </div>
        </div>
    </div>
    <!-- Main Game Container -->
    <div class="flex flex-col items-center gap-4 w-full max-w-5xl">
        <h1 id="main-title" class="text-4xl sm:text-5xl font-extrabold text-white text-center drop-shadow-lg mb-4 uppercase">
            Sloths & Shrimpers Race
        </h1>
        <!-- Loading Screen -->
        <div id="loading-screen" class="bg-gray-800 rounded-2xl p-6 shadow-xl w-full flex flex-col items-center justify-center gap-6 mb-4 border-2 border-gray-700">
            <h2 class="text-3xl font-bold text-center">Loading Assets...</h2>
            <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-purple-500"></div>
        </div>
        <!-- Instructions and Character Selection Screen -->
        <div id="start-screen" class="bg-gray-800 p-6 shadow-xl w-full flex flex-col items-center justify-center gap-6 mb-4 border-2 border-gray-700 hidden">
            <h2 class="text-3xl font-bold mt-4 uppercase text-center">CHOOSE YOUR CHARACTER</h2>
            <div class="flex gap-8">
                <button id="select-sloth-btn" class="character-btn" style="background-image: url('https://github.com/ShrimpieDev/slothXshrimpers/blob/main/sloth-image.jpg?raw=true');"></button>
                <button id="select-shrimp-btn" class="character-btn" style="background-image: url('https://github.com/ShrimpieDev/slothXshrimpers/blob/main/shrimper-image.jpg?raw=true');"></button>
            </div>
            <div class="bg-gray-900 p-6 w-full max-w-lg">
                <h2 class="text-xl font-bold text-center">How to Play</h2>
                <ul class="text-center text-lg list-none mt-4 space-y-2">
                    <li>A -> LEFT, D -> RIGHT, W -> SPEED UP</li>
                    <li>Objective: Survive as long as you can!</li>
                </ul>
            </div>
        </div>
        <!-- Canvas -->
        <canvas id="game-canvas" class="hidden"></canvas>
    </div>
    <footer class="mt-8 text-center text-xs text-gray-400">
        This game made by a community member of <a href="https://x.com/CelestineSloths" target="_blank" class="text-white hover:underline">@CelestineSloths</a> by <a href="https://x.com/Miyulux" target="_blank" class="text-white hover:underline">@Miyulux</a> to attend the event.
    </footer>
    <script>
        let canvas, ctx;
        let gameLoopInterval;
        let speedIncreaseInterval;

        const modal = document.getElementById('modal');
        const modalMessage = document.getElementById('modal-message');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const shareXBtn = document.getElementById('share-x-btn');
        const startScreen = document.getElementById('start-screen');
        const selectSlothBtn = document.getElementById('select-sloth-btn');
        const selectShrimpBtn = document.getElementById('select-shrimp-btn');
        const loadingScreen = document.getElementById('loading-screen');
        const mainTitle = document.getElementById('main-title');

        let playerChar = null;
        let gameActive = false;
        const BASE_SPEED = 8;
        const LANE_WIDTH = 2;
        const LANE_COUNT = 3;
        const OBSTACLE_SPACING_Y = 150; 

        const assets = {
            slothCar: new Image(),
            shrimpCar: new Image(),
            slothObs1: new Image(),
            slothObs2: new Image(),
            shrimpObs1: new Image(),
            shrimpObs2: new Image()
        };

        const assetUrls = {
            slothCar: 'https://github.com/ShrimpieDev/slothXshrimpers/blob/main/sloth-car.png?raw=true',
            shrimpCar: 'https://github.com/ShrimpieDev/slothXshrimpers/blob/main/anoma-car.png?raw=true',
            slothObs1: 'https://github.com/ShrimpieDev/slothXshrimpers/blob/main/sloth-obs-1.png?raw=true',
            slothObs2: 'https://github.com/ShrimpieDev/slothXshrimpers/blob/main/sloth-obs-2.png?raw=true',
            shrimpObs1: 'https://github.com/ShrimpieDev/slothXshrimpers/blob/main/anoma-obs-1.png?raw=true',
            shrimpObs2: 'https://github.com/ShrimpieDev/slothXshrimpers/blob/main/anoma-obs-2.png?raw=true'
        };

        function preloadAssets() {
            const promises = Object.keys(assets).map(key => {
                return new Promise((resolve, reject) => {
                    assets[key].onload = () => resolve();
                    assets[key].onerror = () => reject(new Error(`Failed to load image: ${assetUrls[key]}`));
                    assets[key].src = assetUrls[key];
                });
            });
            return Promise.all(promises);
        }

        function showMessage(message, score) {
            modalMessage.textContent = message;
            modal.classList.remove('hidden');
            if (score !== undefined) {
                shareXBtn.classList.remove('hidden');
                const characterName = gameState.player.type === 'sloth' ? 'Sloth' : 'Shrimper';
                const shareText = `I played as ${characterName} and scored ${score}. Check out this awesome game by @Miyulux for @Shrimpers_nft @anoma`;
                shareXBtn.href = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}`;
            } else {
                shareXBtn.classList.add('hidden');
            }
        }

        closeModalBtn.addEventListener('click', () => {
            modal.classList.add('hidden');
            shareXBtn.classList.add('hidden');
            if (gameState.gameEnded) {
                clearInterval(gameLoopInterval);
                clearInterval(speedIncreaseInterval);
                startScreen.classList.remove('hidden');
                canvas.classList.add('hidden');
                mainTitle.classList.remove('hidden'); 
                
                gameState.player.x = 0;
                gameState.player.y = 0;
                gameState.obstacles = [];
                gameState.gameEnded = false;
                gameState.score = 0;
                gameState.player.speed = BASE_SPEED;
            }
        });
        
        const playerSizes = {
            sloth: { width: 48, height: 66 },
            shrimp: { width: 60, height: 82.5 }
        };
        const obstacleSizes = {
            width: 43.75 * 0.75, 
            height: 43.75 * 0.75
        };

        let gameState = {
            player: { x: 0, y: 0, targetX: 0, currentLane: 1, speed: BASE_SPEED, isActioning: false, type: null, size: {} },
            obstacles: [],
            gameEnded: false,
            score: 0
        };
        
        function setupCanvas() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth > 600 ? 400 : window.innerWidth;
            canvas.height = window.innerWidth > 600 ? 600 : window.innerHeight;
        }

        function clearCanvas() {
            ctx.fillStyle = playerChar === 'sloth' ? '#3e2723' : '#1a237e'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function drawLanes() {
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(canvas.width, 0);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.stroke();

            ctx.strokeStyle = playerChar === 'sloth' ? '#B0B0B0' : '#4a7c6f';
            ctx.lineWidth = LANE_WIDTH;
            const laneSpacing = canvas.width / LANE_COUNT;

            for (let i = 1; i < LANE_COUNT; i++) {
                let x = i * laneSpacing;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        function generateObstacleRow() {
            const obstacleWidth = obstacleSizes.width;
            const obstacleHeight = obstacleSizes.height;
            let type;
            let obstacleImages = [];

            if (playerChar === 'sloth') {
                type = { width: obstacleWidth, height: obstacleHeight, smashable: true };
                obstacleImages = [assets.slothObs1, assets.slothObs2];
            } else { // shrimp
                type = { width: obstacleWidth, height: obstacleHeight, smashable: false };
                obstacleImages = [assets.shrimpObs1, assets.shrimpObs2];
            }
            
            const laneSpacing = canvas.width / LANE_COUNT;
            const obstaclesInRow = [];
            
            const laneIndex = Math.floor(Math.random() * LANE_COUNT);
            const x = laneIndex * laneSpacing + (laneSpacing - type.width) / 2;
            const randomImageIndex = Math.floor(Math.random() * obstacleImages.length);
            const yOffset = Math.random() * 50 - 25; 

            obstaclesInRow.push({
                x: x,
                y: -50 + yOffset,
                type: type,
                width: type.width,
                height: type.height,
                image: obstacleImages[randomImageIndex],
                smashed: false,
                lane: laneIndex
            });
            
            return obstaclesInRow;
        }
        
        function drawPlayer(player) {
            let image = player.type === 'sloth' ? assets.slothCar : assets.shrimpCar;
            ctx.drawImage(image, player.x, player.y, player.size.width, player.size.height);
        }

        function drawObstacle(obstacle) {
            if (obstacle.smashed) return;
            ctx.drawImage(obstacle.image, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        }

        function drawText(text, x, y, size = 20, color = 'white') {
            ctx.fillStyle = color;
            ctx.font = `${size}px Inter`;
            ctx.fillText(text, x, y);
        }

        function checkCollision(player, obstacle) {
            return player.x < obstacle.x + obstacle.width &&
                   player.x + player.size.width > obstacle.x &&
                   player.y < obstacle.y + obstacle.height &&
                   player.y + player.size.height > obstacle.y;
        }

        function gameLoop() {
            if (!gameActive) {
                clearInterval(gameLoopInterval);
                return;
            }
            
            const moveSpeed = 10;
            if (Math.abs(gameState.player.targetX - gameState.player.x) > moveSpeed) {
                if (gameState.player.targetX > gameState.player.x) {
                    gameState.player.x += moveSpeed;
                } else {
                    gameState.player.x -= moveSpeed;
                }
            } else {
                gameState.player.x = gameState.player.targetX;
            }

            gameState.obstacles.forEach(obs => {
                obs.y += gameState.player.speed;
            });
            
            gameState.obstacles.forEach(obs => {
                if (!obs.smashed) {
                    if (checkCollision(gameState.player, obs)) {
                        if (gameState.player.type === 'sloth' && obs.type.smashable && gameState.player.isActioning) {
                            obs.smashed = true;
                        } else {
                            gameActive = false;
                            gameState.gameEnded = true;
                            const message = gameState.player.type === 'sloth' ? "You are too lazy.." : "You couldn't realize your intention";
                            showMessage(message, gameState.score);
                        }
                    }
                }
            });
            
            const lastObstacle = gameState.obstacles[gameState.obstacles.length - 1];
            if (!lastObstacle || lastObstacle.y > OBSTACLE_SPACING_Y) {
                const newRow = generateObstacleRow();
                gameState.obstacles.push(...newRow);
            }

            gameState.obstacles = gameState.obstacles.filter(obs => obs.y < canvas.height);
            gameState.score += 1;

            clearCanvas();
            drawLanes();
            drawPlayer(gameState.player);
            
            gameState.obstacles.forEach(drawObstacle);
            
            drawText(`Score: ${gameState.score}`, 10, 30);
        }

        selectSlothBtn.addEventListener('click', () => {
            playerChar = 'sloth';
            startGame();
        });

        selectShrimpBtn.addEventListener('click', () => {
            playerChar = 'shrimp';
            startGame();
        });

        function startGame() {
            startScreen.classList.add('hidden');
            canvas.classList.remove('hidden');
            mainTitle.classList.add('hidden'); 
            gameActive = true;
            gameState.player.type = playerChar;
            gameState.player.size = playerSizes[playerChar];
            const laneSpacing = canvas.width / LANE_COUNT;
            gameState.player.currentLane = 1; 
            gameState.player.x = gameState.player.currentLane * laneSpacing + (laneSpacing - gameState.player.size.width) / 2;
            gameState.player.targetX = gameState.player.x;
            gameState.player.y = canvas.height - 150;
            gameState.obstacles = [];
            gameState.gameEnded = false;
            gameState.score = 0;
            gameState.player.speed = BASE_SPEED;

            if (playerChar === 'shrimp') {
                canvas.style.backgroundColor = '#1a237e';
            } else {
                canvas.style.backgroundColor = '#3e2723';
            }
            
            gameLoopInterval = setInterval(gameLoop, 1000/60);

            speedIncreaseInterval = setInterval(() => {
                gameState.player.speed += 0.5;
            }, 1000);
        }
        
        window.onload = function() {
            setupCanvas();
            preloadAssets().then(() => {
                loadingScreen.classList.add('hidden');
                startScreen.classList.remove('hidden');
                
                let touchStartX = null;
                const swipeThreshold = 50; 

                document.addEventListener('keydown', (e) => {
                    if (!gameActive) return;
                    const laneSpacing = canvas.width / LANE_COUNT;
                    if (e.key === 'ArrowLeft' || e.key === 'a') {
                        if (gameState.player.currentLane > 0) {
                            gameState.player.currentLane--;
                            gameState.player.targetX = gameState.player.currentLane * laneSpacing + (laneSpacing - gameState.player.size.width) / 2;
                        }
                    } else if (e.key === 'ArrowRight' || e.key === 'd') {
                        if (gameState.player.currentLane < LANE_COUNT - 1) {
                            gameState.player.currentLane++;
                            gameState.player.targetX = gameState.player.currentLane * laneSpacing + (laneSpacing - gameState.player.size.width) / 2;
                        }
                    } else if (e.key === ' ' || e.key === 'ArrowUp') {
                        gameState.player.isActioning = true;
                    } else if (e.key === 'w' || e.key === 'W') {
                        gameState.player.speed = 10;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (!gameActive) return;
                    if (e.key === ' ' || e.key === 'ArrowUp') {
                        gameState.player.isActioning = false;
                    } else if (e.key === 'w' || e.key === 'W') {
                        gameState.player.speed = BASE_SPEED;
                    }
                });

                canvas.addEventListener('touchstart', (e) => {
                    if (!gameActive) return;
                    e.preventDefault();
                    if (e.touches.length === 2) {
                        gameState.player.isActioning = true;
                    } else {
                        touchStartX = e.touches[0].clientX;
                    }
                });

                canvas.addEventListener('touchend', (e) => {
                    if (!gameActive || touchStartX === null) return;
                    e.preventDefault();
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchDiff = touchEndX - touchStartX;
                    const laneSpacing = canvas.width / LANE_COUNT;

                    if (touchDiff > swipeThreshold) {
                        if (gameState.player.currentLane < LANE_COUNT - 1) {
                            gameState.player.currentLane++;
                            const newX = gameState.player.currentLane * laneSpacing + (laneSpacing - gameState.player.size.width) / 2;
                            gameState.player.x = newX;
                            gameState.player.targetX = newX;
                        }
                    } else if (touchDiff < -swipeThreshold) {
                        if (gameState.player.currentLane > 0) {
                            gameState.player.currentLane--;
                            const newX = gameState.player.currentLane * laneSpacing + (laneSpacing - gameState.player.size.width) / 2;
                            gameState.player.x = newX;
                            gameState.player.targetX = newX;
                        }
                    }
                    gameState.player.isActioning = false;
                    touchStartX = null;
                });
            }).catch(error => {
                console.error("Failed to load game assets:", error);
                loadingScreen.textContent = "Error loading game assets.";
                startScreen.classList.remove('hidden');
            });
        }
    </script>
</body>
</html>
